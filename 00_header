#! /bin/sh
set -e


prefix="/usr/local"
exec_prefix="/usr/local"
datarootdir="/usr/local/share"
holy_lang=`echo $LANG | cut -d . -f 1`

export TEXTDOMAIN=holy
export TEXTDOMAINDIR="${datarootdir}/locale"

. "$pkgdatadir/holy-mkconfig_lib"

# Do this as early as possible, since other commands might depend on it.
# (e.g. the `loadfont' command might need lvm or raid modules)
for i in ${holy_PRELOAD_MODULES} ; do
  echo "insmod $i"
done

if [ "x${holy_DEFAULT}" = "x" ] ; then holy_DEFAULT=0 ; fi
if [ "x${holy_DEFAULT}" = "xsaved" ] ; then holy_DEFAULT='${saved_entry}' ; fi
if [ "x${holy_TIMEOUT}" = "x" ] ; then holy_TIMEOUT=5 ; fi
if [ "x${holy_GFXMODE}" = "x" ] ; then holy_GFXMODE=auto ; fi

if [ "x${holy_DEFAULT_BUTTON}" = "x" ] ; then holy_DEFAULT_BUTTON="$holy_DEFAULT" ; fi
if [ "x${holy_DEFAULT_BUTTON}" = "xsaved" ] ; then holy_DEFAULT_BUTTON='${saved_entry}' ; fi
if [ "x${holy_TIMEOUT_BUTTON}" = "x" ] ; then holy_TIMEOUT_BUTTON="$holy_TIMEOUT" ; fi

cat << EOF
if [ -s \$prefix/holyenv ]; then
  load_env
fi
EOF
if [ "x$holy_BUTTON_CMOS_ADDRESS" != "x" ]; then
    cat <<EOF
if cmostest $holy_BUTTON_CMOS_ADDRESS ; then
   set default="${holy_DEFAULT_BUTTON}"
elif [ "\${next_entry}" ] ; then
   set default="\${next_entry}"
   set next_entry=
   save_env next_entry
   set boot_once=true
else
   set default="${holy_DEFAULT}"
fi
EOF
else
    cat <<EOF
if [ "\${next_entry}" ] ; then
   set default="\${next_entry}"
   set next_entry=
   save_env next_entry
   set boot_once=true
else
   set default="${holy_DEFAULT}"
fi
EOF
fi
cat <<EOF

if [ x"\${feature_menuentry_id}" = xy ]; then
  menuentry_id_option="--id"
else
  menuentry_id_option=""
fi

export menuentry_id_option

if [ "\${prev_saved_entry}" ]; then
  set saved_entry="\${prev_saved_entry}"
  save_env saved_entry
  set prev_saved_entry=
  save_env prev_saved_entry
  set boot_once=true
fi

function savedefault {
  if [ -z "\${boot_once}" ]; then
    saved_entry="\${chosen}"
    save_env saved_entry
  fi
}

function load_video {
EOF
if [ -n "${holy_VIDEO_BACKEND}" ]; then
    cat <<EOF
  insmod ${holy_VIDEO_BACKEND}
EOF
else
# If all_video.mod isn't available load all modules available
# with versions prior to introduction of all_video.mod
cat <<EOF
  if [ x\$feature_all_video_module = xy ]; then
    insmod all_video
  else
    insmod efi_gop
    insmod efi_uga
    insmod ieee1275_fb
    insmod vbe
    insmod vga
    insmod video_bochs
    insmod video_cirrus
  fi
EOF
fi
cat <<EOF
}

EOF

serial=0;
gfxterm=0;
for x in ${holy_TERMINAL_INPUT} ${holy_TERMINAL_OUTPUT}; do
    if [ xserial = "x$x" ]; then
	serial=1;
    fi
    if [ xgfxterm = "x$x" ]; then
	gfxterm=1;
    fi
done

if [ "x$serial" = x1 ]; then
    if [ "x${holy_SERIAL_COMMAND}" = "x" ] ; then
	holy_warn "$(gettext "Requested serial terminal but holy_SERIAL_COMMAND is unspecified. Default parameters will be used.")"
	holy_SERIAL_COMMAND=serial
    fi
    echo "${holy_SERIAL_COMMAND}"
fi

if [ "x$gfxterm" = x1 ]; then
    if [ -n "$holy_FONT" ] ; then
       # Make the font accessible
       prepare_holy_to_access_device `${holy_probe} --target=device "${holy_FONT}"`
    cat << EOF
if loadfont `make_system_path_relative_to_its_root "${holy_FONT}"` ; then
EOF
    else
	for dir in "${pkgdatadir}" "`echo '/boot/holy' | sed "s,//*,/,g"`" /usr/share/holy ; do
	    for basename in unicode unifont ascii; do
		path="${dir}/${basename}.pf2"
		if is_path_readable_by_holy "${path}" > /dev/null ; then
		    font_path="${path}"
		else
		    continue
		fi
		break 2
	    done
	done
	if [ -n "${font_path}" ] ; then
    cat << EOF
if [ x\$feature_default_font_path = xy ] ; then
   font=unicode
else
EOF
                # Make the font accessible
		prepare_holy_to_access_device `${holy_probe} --target=device "${font_path}"`
    cat << EOF
    font="`make_system_path_relative_to_its_root "${font_path}"`"
fi

if loadfont \$font ; then
EOF
	    else
    cat << EOF
if loadfont unicode ; then
EOF
	    fi
	fi

    cat << EOF
  set gfxmode=${holy_GFXMODE}
  load_video
  insmod gfxterm
EOF

# Gettext variables and module
if [ "x${LANG}" != "xC" ] &&  [ "x${LANG}" != "x" ]; then
  cat << EOF
  set locale_dir=\$prefix/locale
  set lang=${holy_lang}
  insmod gettext
EOF
fi

cat <<EOF
fi
EOF
fi

case x${holy_TERMINAL_INPUT} in
  x)
    # Just use the native terminal
  ;;
  x*)
    cat << EOF
terminal_input ${holy_TERMINAL_INPUT}
EOF
  ;;
esac

case x${holy_TERMINAL_OUTPUT} in
  x)
    # Just use the native terminal
  ;;
  x*)
    cat << EOF
terminal_output ${holy_TERMINAL_OUTPUT}
EOF
  ;;
esac

if [ "x$gfxterm" = x1 ]; then
    if [ "x$holy_THEME" != x ] && [ -f "$holy_THEME" ] \
	&& is_path_readable_by_holy "$holy_THEME"; then
	gettext_printf "Found theme: %s\n" "$holy_THEME" >&2

	prepare_holy_to_access_device `${holy_probe} --target=device "$holy_THEME"`
	cat << EOF
insmod gfxmenu
EOF
	themedir="`dirname "$holy_THEME"`"
	for x in "$themedir"/*.pf2 "$themedir"/f/*.pf2; do
	    if [ -f "$x" ]; then
		cat << EOF
loadfont (\$root)`make_system_path_relative_to_its_root $x`
EOF
	    fi
	done
	if [ x"`echo "$themedir"/*.jpg`" != x"$themedir/*.jpg" ] || [ x"`echo "$themedir"/*.jpeg`" != x"$themedir/*.jpeg" ]; then
	    cat << EOF
insmod jpeg
EOF
	fi
	if [ x"`echo "$themedir"/*.png`" != x"$themedir/*.png" ]; then
	    cat << EOF
insmod png
EOF
	fi
	if [ x"`echo "$themedir"/*.tga`" != x"$themedir/*.tga" ]; then
	    cat << EOF
insmod tga
EOF
	fi
	    
	cat << EOF
set theme=(\$root)`make_system_path_relative_to_its_root $holy_THEME`
export theme
EOF
    elif [ "x$holy_BACKGROUND" != x ] && [ -f "$holy_BACKGROUND" ] \
	    && is_path_readable_by_holy "$holy_BACKGROUND"; then
	gettext_printf "Found background: %s\n" "$holy_BACKGROUND" >&2
	case "$holy_BACKGROUND" in
	    *.png)         reader=png ;;
	    *.tga)         reader=tga ;;
	    *.jpg|*.jpeg)  reader=jpeg ;;
	    *)             gettext "Unsupported image format" >&2; echo >&2; exit 1 ;;
	esac
	prepare_holy_to_access_device `${holy_probe} --target=device "$holy_BACKGROUND"`
	cat << EOF
insmod $reader
background_image -m stretch `make_system_path_relative_to_its_root "$holy_BACKGROUND"`
EOF
    fi
fi

make_timeout ()
{
    if [ "x${3}" != "x" ] ; then
	timeout="${2}"
	style="${3}"
    elif [ "x${1}" != "x" ] && [ "x${1}" != "x0" ] ; then
	# Handle the deprecated holy_HIDDEN_TIMEOUT scheme.
	timeout="${1}"
	if [ "x${2}" != "x0" ] ; then
	    holy_warn "$(gettext "Setting holy_TIMEOUT to a non-zero value when holy_HIDDEN_TIMEOUT is set is no longer supported.")"
	fi
	if [ "x${holy_HIDDEN_TIMEOUT_QUIET}" = "xtrue" ] ; then
	    style="hidden"
	    verbose=
	else
	    style="countdown"
	    verbose=" --verbose"
	fi
    else
	# No hidden timeout, so treat as holy_TIMEOUT_STYLE=menu
	timeout="${2}"
	style="menu"
    fi
    cat << EOF
if [ x\$feature_timeout_style = xy ] ; then
  set timeout_style=${style}
  set timeout=${timeout}
EOF
    if [ "x${style}" = "xmenu" ] ; then
	cat << EOF
# Fallback normal timeout code in case the timeout_style feature is
# unavailable.
else
  set timeout=${timeout}
EOF
    else
	cat << EOF
# Fallback hidden-timeout code in case the timeout_style feature is
# unavailable.
elif sleep${verbose} --interruptible ${timeout} ; then
  set timeout=0
EOF
    fi
    cat << EOF
fi
EOF
}

if [ "x$holy_BUTTON_CMOS_ADDRESS" != "x" ]; then
    cat <<EOF
if cmostest $holy_BUTTON_CMOS_ADDRESS ; then
EOF
make_timeout "${holy_HIDDEN_TIMEOUT_BUTTON}" "${holy_TIMEOUT_BUTTON}" "${holy_TIMEOUT_STYLE_BUTTON}"
echo else
make_timeout "${holy_HIDDEN_TIMEOUT}" "${holy_TIMEOUT}" "${holy_TIMEOUT_STYLE}"
echo fi
else
make_timeout "${holy_HIDDEN_TIMEOUT}" "${holy_TIMEOUT}" "${holy_TIMEOUT_STYLE}"
fi

if [ "x$holy_BUTTON_CMOS_ADDRESS" != "x" ] && [ "x$holy_BUTTON_CMOS_CLEAN" = "xyes" ]; then
    cat <<EOF
cmosclean $holy_BUTTON_CMOS_ADDRESS
EOF
fi

# Play an initial tune
if [ "x${holy_INIT_TUNE}" != "x" ] ; then
  echo "play ${holy_INIT_TUNE}"
fi

if [ "x${holy_BADRAM}" != "x" ] ; then
  echo "badram ${holy_BADRAM}"
fi
